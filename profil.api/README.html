<!DOCTYPE html>
<html>
<head>
    <title>.Net core Web Api Projektanteckningar/Steps</title>
</head>
<body>

    <h1 id="net-core-web-api-projektanteckningarsteps">.Net core Web Api Projektanteckningar/Steps</h1>
<h3 id="projektkrav">Projektkrav</h3>
<p>Applikationen ska visa en lista av konsultprofiler</p>
<ul>
<li>En profil består av Förnamn, Efternamn och en Beskrivning</li>
</ul>
<p>Som en anonym användare kan jag</p>
<ul>
<li>Registrera mig</li>
<li>Se förnamn på profilerna</li>
</ul>
<p>Som en registrerad användare kan jag</p>
<ul>
<li>Se all information i konsultprofilerna</li>
</ul>
<h2 id="skapa-nytt-projekt-for-api">Skapa nytt projekt för API</h2>
<ul>
<li><p>Lägg till nytt projekt, ASP.NET Core Web Application (.NET Core)
ange namn, profil.api, välj Empty template.</p>
</li>
<li><p>Starta appen i Debug för att verifera att du får upp en browser med meddelandet &quot;Hello World!&quot;</p>
</li>
</ul>
<p>I <a href="Program.cs">Program.cs</a> finns inställningarna för webbservern, t ex om vi vill köra IIS Express eller något annat, vi låter dessa vara som de är.</p>
<p>I <a href="Startup.cs">Startup.cs</a>  konfigurerar man &quot;service dependencies&quot; (i metoden ConfigureServices) och  HTTP Request pipeline (i metoden Configure)</p>
<h4 id="http-request-pipeline">Http Request pipeline</h4>
<p><em>i Startup.cs &gt; Configure</em></p>
<ul>
<li><p>Http Request pipeline består av ett antal &quot;middlewares&quot; vilka kopplas på IApplicationBuilder (app)
vanliga  middelwares hämtar du från nuget, och du kan så klart skriva egna.</p>
</li>
<li><p>Ordningen för middlewares är viktig eftersom en middleware tar emot data från föregående middleware,
gör sin grej och skickar sedan vidare data till nästa i &quot;pipen&quot; (kedjan) [mw 1, mw 2, mw 3] och lyssnar (eventuellt) på resultatet från den/de senare i kedjan [mw 3, mw 2, mw 1]</p>
</li>
<li><p>Vissa middelwares är &quot;terminal&quot; vilket betyder att de inte skickar data vidare, de är sist i kedjan;
några exempel är UseWelcomePage() och Run(), alla middlewares configurerade senare i kedjan kommer alltså inte att köras.</p>
</li>
</ul>
<h4 id="oppna-startup.cs">Öppna <a href="Startup.cs">Startup.cs</a></h4>
<ul>
<li>och lägg till ett repository för att hämta konsultprofilerna</li>
<li>med repositoryt <a href="Models/ConsultantProfileRepository.cs">ConsultantProfileRepository.cs</a> på plats kan vi lägga till en controller för att låta vårt api hämta data.</li>
<li>för att controllern ska hittas behövs routing, det kan man sätta direkt på controllern som vi visar i koden, alternativt i Startup.cs &gt; Configure (eller både och, controllerns konfig väger tyngst)
exempel:</li>
</ul>
<pre><code class="language-language-aspnet">private void ConfigureRoutes(IRouteBuilder routeBuilder)
{
	routeBuilder.MapRoute(&quot;Default&quot;,
		&quot;{controller=Home}/{action=Index}/{id?}&quot;); // controller=Home &gt;&gt; om controller name inte hittas (eller inte angavs), redirect till HomeController med default action(metod) Index
}
// används i Configure enligt, app.UseMvc(ConfigureRoutes)
</code></pre>
<ul>
<li>nu har vi ett fungerande api som kan leverera konsultprofiler, nästa steg är att lägga till autentisering vilket vi gör med .Net Core Identity och <a href="https://github.com/IdentityServer/IdentityServer4">Identity Server 4</a></li>
</ul>
<h2 id="nytt-projekt-for-identityserver-och.net-core-identity">Nytt projekt för IdentityServer och .Net Core Identity</h2>
<p>Här följer jag exemplet från <a href="https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html">Identity Server Quickstarts &gt; Using ASP.NET Core Identity</a>, (det finns även ett <a href="https://github.com/IdentityServer/IdentityServer4.Samples/tree/dev/Quickstarts/6_AspNetIdentity">exempelprojekt att ladda ner här</a>,
med <a href="https://github.com/IdentityServer/IdentityServer4.Quickstart.UI">deras färdiga UI</a></p>
<h3 id="folj-stegen-fran-new-project-for-asp.net-identity-till-och-med-creating-a-user">följ stegen från &quot;New Project for ASP.NET Identity&quot; till och med &quot;Creating a user&quot;</h3>
<h4 id="add-identityserver-packages">&quot;Add IdentityServer packages&quot;</h4>
<ul>
<li>när jag uppdaterade alla paket till det senaste misslyckades nuget med restore, vilket löstes genom att uppdatera nuget till senaste beta <a href="https://docs.nuget.org/ndocs/guides/install-nuget">https://docs.nuget.org/ndocs/guides/install-nuget</a> ,</li>
<li>efter det följde jag denna länk för uppdatering av core till .net core 1.1 <a href="https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/">https://blogs.msdn.microsoft.com/webdev/2016/11/16/announcing-asp-net-core-1-1/</a></li>
</ul>
<h4 id="configure-identityserver">&quot;Configure IdentityServer&quot;</h4>
<ul>
<li>konfiguration av IdentityServer &quot;InMemory&quot; (dvs statisk hårdkodad konfiguration)</li>
<li>Med Identity Server på plats kan vi lägga till till Authorization på vårt Api, ConsultantProfileController.Get() &gt;
<ul>
<li>Än så länge är det öppet att hämta data från <a href="http://localhost:57624/api/consultantprofile">http://localhost:57624/api/consultantprofile</a> men nu är det dags att begränsa åtkomsten.</li>
<li>Lägg till &quot;Authorize&quot; på Get(), om du försöker hämta data nu får du tillbaks status code &quot;401 Unauthorized&quot;</li>
</ul>
</li>
<li>Vi behöver även konfigurera vårt api till att använda vår IdentityServer för autentisering, dvs så att vårt api godkänner tokens utfärdade av vår IdentityServer, detta gör vi i profil.api.Startup
<ul>
<li>Lägg till &quot;IdentityServer4.AccessTokenValidation&quot;: &quot;1.0.1&quot; som en dependency i project.json</li>
<li>lägg till denna middleware i Startup.Config</li>
</ul>
</li>
</ul>
<h4 id="creating-the-user-database">&quot;Creating the user database&quot;</h4>
<ul>
<li>Eftersom vi använder Identity för användarhanteringen behöver vi initiera databasen, har du som jag uppdaterat .net core till 1.1 följ dessa steg (annars får du varningen &quot;No executable found matching command &quot;dotnet-ef&quot; när du försöker initiera databasen)
<ul>
<li>lägg til följande nugetpaket (<a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet">https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/dotnet</a>)
<ul>
<li>under dependencies: &quot;Microsoft.EntityFrameworkCore.Design&quot;: {&quot;type&quot;: &quot;build&quot;, &quot;version&quot;: &quot;1.1.0&quot;}</li>
<li>under tools: &quot;Microsoft.EntityFrameworkCore.Tools&quot;: &quot;1.1.0-preview4-final&quot;,
&quot;Microsoft.EntityFrameworkCore.Tools.DotNet&quot;: &quot;1.1.0-preview4-final&quot;,</li>
</ul>
</li>
</ul>
</li>
<li>öppna en kommandoprompt i projektkatalogen för vår IdentityServer och kör följande kommandon
<ul>
<li>&quot;dotnet ef migrations add InitialDbMigration&quot; för att skapa vår baseline, detta är inte nödvändigt.</li>
<li>&quot;dotnet ef database update&quot; för att initiera databasen.</li>
</ul>
</li>
</ul>
<h4 id="creating-a-user">&quot;Creating a user&quot;</h4>
<ul>
<li>Starta api och IdentityServer och öppna identityserver (<a href="http://localhost:5000">http://localhost:5000</a>)</li>
<li>Registrera en användare (komplexa lösenord, t ex Abc123!, krävs som standard)</li>
<li>Nu när vi har en användare kan vi testa vårt api från ett verktyg som <a href="https://www.getpostman.com/">Postman</a>
<ul>
<li>anropa först IdentityServer, <a href="http://localhost:5000/connect/token,">http://localhost:5000/connect/token,</a> från postman med följande inställningar
<ul>
<li>(client_id, client_secret, grant_type och scope kommer från Config.GetClients(), username och password är från användaren du nyss registrerade) <img src="ReadMe_images/connect_token_settings.png" alt="Connect Token Settings" /> som svar ska du få ett json-objekt med bla a en &quot;access_token&quot;, kopiera access_token och öppna en ny flik för att skapa ett anrop mot vårt api</li>
</ul>
</li>
<li>anropa därefter vårt api enligt bilden, <a href="http://localhost:57624/api/consultantprofile,">http://localhost:57624/api/consultantprofile,</a> med headern &quot;Authorization&quot; &quot;Bearer [tokenstring]&quot; <img src="ReadMe_images/api-anrop_bearer-token.png" alt="Api Anrop Bearer Token" /> och som svar bör du nu få data från apiet.</li>
</ul>
</li>
</ul>
<h2 id="reflektion">Reflektion</h2>
<p>Ok, nu har vi alltså satt upp ett api som vi kan anropa för att hämta konsultprofiler innehållande Förnamn, Efternamn och Beskrivning.
Men just nu måste jag vara en registrerad användare för att kunna se profildata, enligt kravet ska jag kunna se profilernas förnamn även om jag inte är registrerad.</p>
<ul>
<li>Här kan vi välja olika lösningar
<ul>
<li>Den ena är olika api actions (controller-metoder) där en action levererar data till icke autentiserade användare och en annan action levererar data till autentiserade användare,</li>
<li>En annan lösning är att ta bort attributet &quot;Authorize&quot; från vår &quot;Get&quot;-action och kontrollera behörighet i denna.</li>
<li>Eftersom jag anser att den som frågar efter data ska veta vad den frågar efter samt att jag vill ha renare metoder i mitt api väljer jag det första alternativet, med separata actions. Visst hade det varigt trevligt om klienten bara behövde anropa en metod och sen kunde visa upp data oavsett om det var fulla profilerna eller bara förnamnen, men det är mycket tydligare för klienten att returnera &quot;401 Unauthorized&quot; än att returnera begränsad data, dessutom blir som sagt api-koden renare; ren kod == bra kod.</li>
</ul>
</li>
</ul>
<h3 id="uppdatera-api">Uppdatera api</h3>
<p>Så i <a href="Controllers/ConsultantProfileController.cs">ConsultantProfileController</a> uppdaterar vi våra actions enligt följande</p>
<pre><code class="language-language-aspnet">[HttpGet]
[Route(&quot;&quot;)]//default Getmetod, bara för att jag vill ge metoden ett tydligare namn än &quot;Get&quot;, 
public IEnumerable&lt;ConsultantProfileLimitedViewModel&gt; GetLimitedConsultantProfiles()
{
    return consultantProfileRepository.GetAllLimited();
}

[HttpGet]
[Authorize]
[Route(&quot;GetFull&quot;)]
public IEnumerable&lt;ConsultantProfile&gt; GetFullConsultantProfiles()
{
    return consultantProfileRepository.GetAll();
}
</code></pre>
<ul>
<li>Perfekt,
<ul>
<li><a href="http://localhost:57624/api/consultantprofile/getfull">http://localhost:57624/api/consultantprofile/getfull</a> returnerar hela profilen och kräver autentisering.</li>
<li><a href="http://localhost:57624/api/consultantprofile">http://localhost:57624/api/consultantprofile</a> kräver ingen autentisering, men.. oops, vi får både för och efternamn; det stämmer inte helt med kraven..</li>
</ul>
</li>
</ul>


</body>
</html>